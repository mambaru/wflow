<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>wflow: Класс wflow::workflow</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">wflow
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Титульная&#160;страница</span></a></li>
      <li class="current"><a href="annotated.html"><span>Классы</span></a></li>
      <li><a href="files.html"><span>Файлы</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Классы</span></a></li>
      <li><a href="classes.html"><span>Алфавитный&#160;указатель&#160;классов</span></a></li>
      <li><a href="functions.html"><span>Члены&#160;классов</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>wflow</b></li><li class="navelem"><a class="el" href="classwflow_1_1workflow.html">workflow</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Открытые типы</a> &#124;
<a href="#pub-methods">Открытые члены</a> &#124;
<a href="classwflow_1_1workflow-members.html">Полный список членов класса</a>  </div>
  <div class="headertitle">
<div class="title">Класс wflow::workflow</div>  </div>
</div><!--header-->
<div class="contents">

<p>И это хорошо  
 <a href="classwflow_1_1workflow.html#details">Подробнее...</a></p>

<p><code>#include &lt;<a class="el" href="workflow_8hpp_source.html">workflow.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Открытые типы</h2></td></tr>
<tr class="memitem:a7c22a6961d118354353fedf784109a39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c22a6961d118354353fedf784109a39"></a>
typedef ::wflow::asio::io_service&#160;</td><td class="memItemRight" valign="bottom"><b>io_service_type</b></td></tr>
<tr class="separator:a7c22a6961d118354353fedf784109a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7472aecc04ba9e55c4a57bc3dbaa67e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7472aecc04ba9e55c4a57bc3dbaa67e7"></a>
typedef std::function&lt; void() &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>post_handler</b></td></tr>
<tr class="separator:a7472aecc04ba9e55c4a57bc3dbaa67e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbaa16e329c57de5b14f2a4faeea00bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbaa16e329c57de5b14f2a4faeea00bd"></a>
typedef std::function&lt; void() &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>drop_handler</b></td></tr>
<tr class="separator:adbaa16e329c57de5b14f2a4faeea00bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa4292a3984598d666346323266dc0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fa4292a3984598d666346323266dc0a"></a>
typedef std::function&lt; bool()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>timer_handler</b></td></tr>
<tr class="separator:a6fa4292a3984598d666346323266dc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a4f8a5cfd2bb31d29e77442b8e9410"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8a4f8a5cfd2bb31d29e77442b8e9410"></a>
typedef std::function&lt; void(bool)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>callback_timer_handler</b></td></tr>
<tr class="separator:ab8a4f8a5cfd2bb31d29e77442b8e9410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b781c2615ff47b0d6b2b49d86cff7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36b781c2615ff47b0d6b2b49d86cff7e"></a>
typedef std::function&lt; void(callback_timer_handler)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>async_timer_handler</b></td></tr>
<tr class="separator:a36b781c2615ff47b0d6b2b49d86cff7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb77a0d34b629b141b704e2613880cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bb77a0d34b629b141b704e2613880cb"></a>
typedef std::chrono::system_clock&#160;</td><td class="memItemRight" valign="bottom"><b>clock_t</b></td></tr>
<tr class="separator:a7bb77a0d34b629b141b704e2613880cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9d747b32e9578be3c2b105e5d97719"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e9d747b32e9578be3c2b105e5d97719"></a>
typedef std::chrono::time_point&lt; clock_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>time_point_t</b></td></tr>
<tr class="separator:a7e9d747b32e9578be3c2b105e5d97719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acadb00906beac1a0cafa23e5b036f43a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acadb00906beac1a0cafa23e5b036f43a"></a>
typedef time_point_t::duration&#160;</td><td class="memItemRight" valign="bottom"><b>duration_t</b></td></tr>
<tr class="separator:acadb00906beac1a0cafa23e5b036f43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa518f5f9fc1003db600a9b49b6ac1457"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa518f5f9fc1003db600a9b49b6ac1457"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>timer_id_t</b></td></tr>
<tr class="separator:aa518f5f9fc1003db600a9b49b6ac1457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8426cf152ac6054deb073f5229db5f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8426cf152ac6054deb073f5229db5f9"></a>
typedef task_manager::timer_type&#160;</td><td class="memItemRight" valign="bottom"><b>timer_type</b></td></tr>
<tr class="separator:ad8426cf152ac6054deb073f5229db5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Открытые члены</h2></td></tr>
<tr class="memitem:a30291da755df1cee713c2190020bac58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30291da755df1cee713c2190020bac58"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>workflow</b> (const <a class="el" href="classwflow_1_1workflow.html">workflow</a> &amp;)=delete</td></tr>
<tr class="separator:a30291da755df1cee713c2190020bac58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2b29a79dd73f2d0986f8d539b35bfe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b2b29a79dd73f2d0986f8d539b35bfe"></a>
<a class="el" href="classwflow_1_1workflow.html">workflow</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classwflow_1_1workflow.html">workflow</a> &amp;)=delete</td></tr>
<tr class="separator:a8b2b29a79dd73f2d0986f8d539b35bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e93b275ab157fed9740d8890d3f34d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwflow_1_1workflow.html#a67e93b275ab157fed9740d8890d3f34d">workflow</a> (<a class="el" href="structwflow_1_1workflow__options.html">workflow_options</a> opt)</td></tr>
<tr class="memdesc:a67e93b275ab157fed9740d8890d3f34d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Конструктор без поддержки однопоточного режима.  <a href="#a67e93b275ab157fed9740d8890d3f34d">Подробнее...</a><br /></td></tr>
<tr class="separator:a67e93b275ab157fed9740d8890d3f34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e30c83841751487b8cf835f9b27184"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwflow_1_1workflow.html#aa6e30c83841751487b8cf835f9b27184">workflow</a> (io_service_type &amp;io, <a class="el" href="structwflow_1_1workflow__options.html">workflow_options</a> opt=<a class="el" href="structwflow_1_1workflow__options.html">workflow_options</a>())</td></tr>
<tr class="separator:aa6e30c83841751487b8cf835f9b27184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac078e4d80f614092a138d0be0ba78bed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwflow_1_1workflow.html#ac078e4d80f614092a138d0be0ba78bed">start</a> ()</td></tr>
<tr class="separator:ac078e4d80f614092a138d0be0ba78bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609835e9fafda3a362ebbb472d63268a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwflow_1_1workflow.html#a609835e9fafda3a362ebbb472d63268a">reconfigure</a> (<a class="el" href="structwflow_1_1workflow__options.html">workflow_options</a> opt)</td></tr>
<tr class="separator:a609835e9fafda3a362ebbb472d63268a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16d7071e782ec5fedfa5fb9be67eaac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae16d7071e782ec5fedfa5fb9be67eaac"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:ae16d7071e782ec5fedfa5fb9be67eaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953d46a7994909524970c4ab750c1f07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwflow_1_1workflow.html#a953d46a7994909524970c4ab750c1f07">stop</a> ()</td></tr>
<tr class="separator:a953d46a7994909524970c4ab750c1f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4195f4f557ed076268185c4565f780"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwflow_1_1workflow.html#a5d4195f4f557ed076268185c4565f780">post</a> (post_handler handler, drop_handler drop=nullptr)</td></tr>
<tr class="separator:a5d4195f4f557ed076268185c4565f780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f73cc8d8b0296c7d54adf6abc2695d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwflow_1_1workflow.html#a7f73cc8d8b0296c7d54adf6abc2695d5">post</a> (time_point_t tp, post_handler handler, drop_handler drop=nullptr)</td></tr>
<tr class="separator:a7f73cc8d8b0296c7d54adf6abc2695d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55118251c8cff0d77cc58a13a7f4a68"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwflow_1_1workflow.html#aa55118251c8cff0d77cc58a13a7f4a68">post</a> (duration_t duration, post_handler handler, drop_handler drop=nullptr)</td></tr>
<tr class="separator:aa55118251c8cff0d77cc58a13a7f4a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4296e274c45240aa597f88fa9b2be2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwflow_1_1workflow.html#aea4296e274c45240aa597f88fa9b2be2">safe_post</a> (post_handler handler)</td></tr>
<tr class="separator:aea4296e274c45240aa597f88fa9b2be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d4bbe7f9456b3e8a96cdfeadf3566a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwflow_1_1workflow.html#a34d4bbe7f9456b3e8a96cdfeadf3566a">safe_post</a> (time_point_t tp, post_handler handler)</td></tr>
<tr class="separator:a34d4bbe7f9456b3e8a96cdfeadf3566a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6958512e4be3e7ff55afb0824a5347"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwflow_1_1workflow.html#aef6958512e4be3e7ff55afb0824a5347">safe_post</a> (duration_t duration, post_handler handler)</td></tr>
<tr class="separator:aef6958512e4be3e7ff55afb0824a5347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8109df8f191419c2bcfc48a1745121"><td class="memItemLeft" align="right" valign="top">timer_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwflow_1_1workflow.html#a0e8109df8f191419c2bcfc48a1745121">create_timer</a> (duration_t duration, timer_handler handler, expires_at expires=expires_at::after)</td></tr>
<tr class="separator:a0e8109df8f191419c2bcfc48a1745121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14114268cd6fb1973ce585bca40e57e4"><td class="memItemLeft" align="right" valign="top">timer_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwflow_1_1workflow.html#a14114268cd6fb1973ce585bca40e57e4">create_async_timer</a> (duration_t duration, async_timer_handler ahandler, expires_at expires=expires_at::after)</td></tr>
<tr class="separator:a14114268cd6fb1973ce585bca40e57e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa928235f0b71f3190cc3789a15cf7c93"><td class="memItemLeft" align="right" valign="top">timer_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwflow_1_1workflow.html#aa928235f0b71f3190cc3789a15cf7c93">create_timer</a> (duration_t statrt_duration, duration_t duration, timer_handler handler, expires_at expires=expires_at::after)</td></tr>
<tr class="separator:aa928235f0b71f3190cc3789a15cf7c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d16aaec3c7a5fcfd07166a6804afb5"><td class="memItemLeft" align="right" valign="top">timer_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwflow_1_1workflow.html#a25d16aaec3c7a5fcfd07166a6804afb5">create_async_timer</a> (duration_t start_duration, duration_t duration, async_timer_handler ahandler, expires_at expires=expires_at::after)</td></tr>
<tr class="separator:a25d16aaec3c7a5fcfd07166a6804afb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ee06f50f5cef57071b690623be268b"><td class="memItemLeft" align="right" valign="top">timer_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwflow_1_1workflow.html#ab1ee06f50f5cef57071b690623be268b">create_timer</a> (time_point_t tp, duration_t duration, timer_handler handler, expires_at expires=expires_at::after)</td></tr>
<tr class="separator:ab1ee06f50f5cef57071b690623be268b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1eeb3e91fcf31c34455abc98ab1aed"><td class="memItemLeft" align="right" valign="top">timer_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwflow_1_1workflow.html#a6b1eeb3e91fcf31c34455abc98ab1aed">create_async_timer</a> (time_point_t tp, duration_t duration, async_timer_handler ahandler, expires_at expires=expires_at::after)</td></tr>
<tr class="separator:a6b1eeb3e91fcf31c34455abc98ab1aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c41466592cc8f8c2c46b439e4da4fe0"><td class="memItemLeft" align="right" valign="top">timer_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwflow_1_1workflow.html#a7c41466592cc8f8c2c46b439e4da4fe0">create_timer</a> (std::string tp, duration_t duration, timer_handler handler, expires_at expires=expires_at::after)</td></tr>
<tr class="separator:a7c41466592cc8f8c2c46b439e4da4fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4066f3d0a4c9c30cb376d914cdb361"><td class="memItemLeft" align="right" valign="top">timer_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwflow_1_1workflow.html#a4c4066f3d0a4c9c30cb376d914cdb361">create_async_timer</a> (std::string tp, duration_t duration, async_timer_handler ahandler, expires_at expires=expires_at::after)</td></tr>
<tr class="separator:a4c4066f3d0a4c9c30cb376d914cdb361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655ba126612a77fe92dd28dfaeae397c"><td class="memItemLeft" align="right" valign="top">timer_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwflow_1_1workflow.html#a655ba126612a77fe92dd28dfaeae397c">create_timer</a> (std::string tp, timer_handler handler, expires_at expires=expires_at::after)</td></tr>
<tr class="separator:a655ba126612a77fe92dd28dfaeae397c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea33462fe0aa506e83f6b73c66e9ea4"><td class="memItemLeft" align="right" valign="top">timer_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwflow_1_1workflow.html#a3ea33462fe0aa506e83f6b73c66e9ea4">create_async_timer</a> (std::string tp, async_timer_handler ahandler, expires_at expires=expires_at::after)</td></tr>
<tr class="separator:a3ea33462fe0aa506e83f6b73c66e9ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77db499fea94a94f76eeae3e64449efa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwflow_1_1workflow.html#a77db499fea94a94f76eeae3e64449efa">release_timer</a> (timer_id_t id)</td></tr>
<tr class="separator:a77db499fea94a94f76eeae3e64449efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8ec8d4bd0205254c6bbb0f698cad43"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwflow_1_1workflow.html#a9f8ec8d4bd0205254c6bbb0f698cad43">detach_timer</a> (timer_id_t id)</td></tr>
<tr class="separator:a9f8ec8d4bd0205254c6bbb0f698cad43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c7e3b77008db65f12da1247fcfad88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06c7e3b77008db65f12da1247fcfad88"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>timer_count</b> () const </td></tr>
<tr class="separator:a06c7e3b77008db65f12da1247fcfad88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0b4209eebd03559014063e4846a105"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a0b4209eebd03559014063e4846a105"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>full_size</b> () const </td></tr>
<tr class="separator:a0a0b4209eebd03559014063e4846a105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f81c6d8cd056c9ee424ba529e5db6b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f81c6d8cd056c9ee424ba529e5db6b8"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>safe_size</b> () const </td></tr>
<tr class="separator:a1f81c6d8cd056c9ee424ba529e5db6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228693c7876acdb678e87b9b31547076"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a228693c7876acdb678e87b9b31547076"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>unsafe_size</b> () const </td></tr>
<tr class="separator:a228693c7876acdb678e87b9b31547076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50750159158f1d061a653e864d93f3a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50750159158f1d061a653e864d93f3a5"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>dropped</b> () const </td></tr>
<tr class="separator:a50750159158f1d061a653e864d93f3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b294d169410e46f64a01eea0347cc2"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae9b294d169410e46f64a01eea0347cc2"></a>
template&lt;typename Req , typename Res , typename I , typename MemFun , typename Handler &gt; </td></tr>
<tr class="memitem:ae9b294d169410e46f64a01eea0347cc2"><td class="memTemplItemLeft" align="right" valign="top">timer_id_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_requester</b> (duration_t d, std::shared_ptr&lt; I &gt; i, MemFun mem_fun, Handler handler)</td></tr>
<tr class="separator:ae9b294d169410e46f64a01eea0347cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526dcfa0e0075b8d17cc12b24b14d639"><td class="memTemplParams" colspan="2"><a class="anchor" id="a526dcfa0e0075b8d17cc12b24b14d639"></a>
template&lt;typename Req , typename Res , typename I , typename MemFun , typename Handler &gt; </td></tr>
<tr class="memitem:a526dcfa0e0075b8d17cc12b24b14d639"><td class="memTemplItemLeft" align="right" valign="top">timer_id_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_requester</b> (duration_t sd, duration_t d, std::shared_ptr&lt; I &gt; i, MemFun mem_fun, Handler handler)</td></tr>
<tr class="separator:a526dcfa0e0075b8d17cc12b24b14d639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b84d79986e95b0f54b38fbec8bb556"><td class="memTemplParams" colspan="2"><a class="anchor" id="a65b84d79986e95b0f54b38fbec8bb556"></a>
template&lt;typename Req , typename Res , typename I , typename MemFun , typename Handler &gt; </td></tr>
<tr class="memitem:a65b84d79986e95b0f54b38fbec8bb556"><td class="memTemplItemLeft" align="right" valign="top">timer_id_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_requester</b> (std::string st, duration_t d, std::shared_ptr&lt; I &gt; i, MemFun mem_fun, Handler handler)</td></tr>
<tr class="separator:a65b84d79986e95b0f54b38fbec8bb556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0385ea9a187173d7b4c337d1d0e1c243"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0385ea9a187173d7b4c337d1d0e1c243"></a>
template&lt;typename Req , typename Res , typename I , typename MemFun , typename Handler &gt; </td></tr>
<tr class="memitem:a0385ea9a187173d7b4c337d1d0e1c243"><td class="memTemplItemLeft" align="right" valign="top">timer_id_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_requester</b> (time_point_t tp, duration_t d, std::shared_ptr&lt; I &gt; i, MemFun mem_fun, Handler handler)</td></tr>
<tr class="separator:a0385ea9a187173d7b4c337d1d0e1c243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fee35de1d7f63986b0e1852b819a1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86fee35de1d7f63986b0e1852b819a1a"></a>
std::shared_ptr&lt; task_manager &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>manager</b> () const </td></tr>
<tr class="separator:a86fee35de1d7f63986b0e1852b819a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc63ff720a17633bfd061bec23597d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aadc63ff720a17633bfd061bec23597d8"></a>
std::shared_ptr&lt; timer_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_timer</b> () const </td></tr>
<tr class="separator:aadc63ff720a17633bfd061bec23597d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Подробное описание</h2>
<div class="textblock"><p>И это хорошо </p>
<p>подробное описание </p>
</div><h2 class="groupheader">Конструктор(ы)</h2>
<a class="anchor" id="a67e93b275ab157fed9740d8890d3f34d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wflow::workflow::workflow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwflow_1_1workflow__options.html">workflow_options</a>&#160;</td>
          <td class="paramname"><em>opt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Конструктор без поддержки однопоточного режима. </p>
<p>В конфигурации необходимо указать threads=1 или больше При threads=0 задачи из очереди обрабатываться не будут</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>- опции. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6e30c83841751487b8cf835f9b27184"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wflow::workflow::workflow </td>
          <td>(</td>
          <td class="paramtype">io_service_type &amp;&#160;</td>
          <td class="paramname"><em>io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwflow_1_1workflow__options.html">workflow_options</a>&#160;</td>
          <td class="paramname"><em>opt</em> = <code><a class="el" href="structwflow_1_1workflow__options.html">workflow_options</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Универсальный конструктор с поддержкой нескольких потоков (при threads=1 или больше) или однопоточный вариант (threads=0, в этом случае обработка очереди будет происходить при вызове io.run() или аналогичных.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">io</td><td>- ссылка на boost::asio::io_service</td></tr>
  </table>
  </dd>
</dl>
<p>При threads=1 или большем создается свой объект io_service, а io не используется </p>

</div>
</div>
<h2 class="groupheader">Методы</h2>
<a class="anchor" id="a14114268cd6fb1973ce585bca40e57e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">workflow::timer_id_t wflow::workflow::create_async_timer </td>
          <td>(</td>
          <td class="paramtype">duration_t&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">async_timer_handler&#160;</td>
          <td class="paramname"><em>ahandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">expires_at&#160;</td>
          <td class="paramname"><em>expires</em> = <code>expires_at::after</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Создает асинхронный таймер, обработчик которого выполняется с заданной периодичностью </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>интервал таймера </td></tr>
    <tr><td class="paramname">ahandler</td><td>обработчик таймера std::function&lt;void(callback_timer_handler)&gt;, который должен вызвать callback_timer_handler(true), если таймер должен продолжать работать и callback_timer_handler(false) - для завершения. </td></tr>
    <tr><td class="paramname">expires</td><td>если expires_at::after (по умолчанию), то отсчет до следующего запуска после выполнения обработчика таймера (вызова callback_timer_handler из обработчика)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>идентификатор таймера, который можно использовать для остановки таймера </dd></dl>

</div>
</div>
<a class="anchor" id="a25d16aaec3c7a5fcfd07166a6804afb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">workflow::timer_id_t wflow::workflow::create_async_timer </td>
          <td>(</td>
          <td class="paramtype">duration_t&#160;</td>
          <td class="paramname"><em>start_duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">duration_t&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">async_timer_handler&#160;</td>
          <td class="paramname"><em>ahandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">expires_at&#160;</td>
          <td class="paramname"><em>expires</em> = <code>expires_at::after</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Создает асинхронный таймер, обработчик которого выполняется с заданной периодичностью через определенный интервал времени </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_duration</td><td>интервал времени, через который запустить таймер </td></tr>
    <tr><td class="paramname">duration</td><td>интервал таймера </td></tr>
    <tr><td class="paramname">ahandler</td><td>обработчик таймера std::function&lt;void(callback_timer_handler)&gt;, который должен вызвать callback_timer_handler(true), если таймер должен продолжать работать и callback_timer_handler(false) - для завершения. </td></tr>
    <tr><td class="paramname">expires</td><td>если expires_at::after (по умолчанию), то отсчет до следующего запуска после выполнения обработчика таймера (вызова callback_timer_handler из обработчика)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>идентификатор таймера, который можно использовать для остановки таймера </dd></dl>

</div>
</div>
<a class="anchor" id="a6b1eeb3e91fcf31c34455abc98ab1aed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">workflow::timer_id_t wflow::workflow::create_async_timer </td>
          <td>(</td>
          <td class="paramtype">time_point_t&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">duration_t&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">async_timer_handler&#160;</td>
          <td class="paramname"><em>ahandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">expires_at&#160;</td>
          <td class="paramname"><em>expires</em> = <code>expires_at::after</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Создает асинхронный таймер, обработчик которого выполняется с заданной периодичностью начиная с определенного момента времени </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">tp</td><td>момент времени, начиная с которого запустить таймер </td></tr>
    <tr><td class="paramname">duration</td><td>интервал таймера </td></tr>
    <tr><td class="paramname">ahandler</td><td>обработчик таймера std::function&lt;void(callback_timer_handler)&gt;, который должен вызвать callback_timer_handler(true), если таймер должен продолжать работать и callback_timer_handler(false) - для завершения. </td></tr>
    <tr><td class="paramname">expires</td><td>если expires_at::after (по умолчанию), то отсчет до следующего запуска после выполнения обработчика таймера (вызова callback_timer_handler из обработчика)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>идентификатор таймера, который можно использовать для остановки таймера </dd></dl>

</div>
</div>
<a class="anchor" id="a4c4066f3d0a4c9c30cb376d914cdb361"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">workflow::timer_id_t wflow::workflow::create_async_timer </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">duration_t&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">async_timer_handler&#160;</td>
          <td class="paramname"><em>ahandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">expires_at&#160;</td>
          <td class="paramname"><em>expires</em> = <code>expires_at::after</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Создает асинхронный таймер, обработчик которого выполняется с заданной периодичностью начиная с определенного момента времени </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">tp</td><td>момент времени, начиная с которого запустить таймер (строка в формате "22:00:00") </td></tr>
    <tr><td class="paramname">duration</td><td>интервал таймера </td></tr>
    <tr><td class="paramname">ahandler</td><td>обработчик таймера std::function&lt;void(callback_timer_handler)&gt;, который должен вызвать callback_timer_handler(true), если таймер должен продолжать работать и callback_timer_handler(false) - для завершения. </td></tr>
    <tr><td class="paramname">expires</td><td>если expires_at::after (по умолчанию), то отсчет до следующего запуска после выполнения обработчика таймера (вызова callback_timer_handler из обработчика)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>идентификатор таймера, который можно использовать для остановки таймера </dd></dl>

</div>
</div>
<a class="anchor" id="a3ea33462fe0aa506e83f6b73c66e9ea4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">workflow::timer_id_t wflow::workflow::create_async_timer </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">async_timer_handler&#160;</td>
          <td class="paramname"><em>ahandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">expires_at&#160;</td>
          <td class="paramname"><em>expires</em> = <code>expires_at::after</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Создает асинхронный таймер, обработчик которого выполняется раз в сутки с определенного момента времени </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">tp</td><td>момент времени, начиная с которого запустить таймер (строка в формате "22:00:00") </td></tr>
    <tr><td class="paramname">ahandler</td><td>обработчик таймера std::function&lt;void(callback_timer_handler)&gt;, который должен вызвать callback_timer_handler(true), если таймер должен продолжать работать и callback_timer_handler(false) - для завершения. </td></tr>
    <tr><td class="paramname">expires</td><td>если expires_at::after (по умолчанию), то отсчет до следующего запуска после выполнения обработчика таймера (вызова callback_timer_handler из обработчика)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>идентификатор таймера, который можно использовать для остановки таймера </dd></dl>

</div>
</div>
<a class="anchor" id="a0e8109df8f191419c2bcfc48a1745121"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">workflow::timer_id_t wflow::workflow::create_timer </td>
          <td>(</td>
          <td class="paramtype">duration_t&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timer_handler&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">expires_at&#160;</td>
          <td class="paramname"><em>expires</em> = <code>expires_at::after</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Создает таймер, обработчик которого выполняется с заданной периодичностью </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>интервал таймера </td></tr>
    <tr><td class="paramname">handler</td><td>обработчик таймера std::function&lt;bool()&gt;, который должен возвращать true, если таймер должен продолжать работать и false - для завершения. </td></tr>
    <tr><td class="paramname">expires</td><td>если expires_at::after (по умолчанию), то отсчет до следующего запуска после выполнения обработчика таймера</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>идентификатор таймера, который можно использовать для остановки таймера </dd></dl>

</div>
</div>
<a class="anchor" id="aa928235f0b71f3190cc3789a15cf7c93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">workflow::timer_id_t wflow::workflow::create_timer </td>
          <td>(</td>
          <td class="paramtype">duration_t&#160;</td>
          <td class="paramname"><em>statrt_duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">duration_t&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timer_handler&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">expires_at&#160;</td>
          <td class="paramname"><em>expires</em> = <code>expires_at::after</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Создает таймер, обработчик которого выполняется с заданной периодичностью через определенный интервал времени </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_duration</td><td>интервал времени, через который запустить таймер </td></tr>
    <tr><td class="paramname">duration</td><td>интервал таймера </td></tr>
    <tr><td class="paramname">handler</td><td>обработчик таймера std::function&lt;bool()&gt;, который должен возвращать true, если таймер должен продолжать работать и false - для завершения. </td></tr>
    <tr><td class="paramname">expires</td><td>если expires_at::after (по умолчанию), то отсчет до следующего запуска после выполнения обработчика таймера</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>идентификатор таймера, который можно использовать для остановки таймера </dd></dl>

</div>
</div>
<a class="anchor" id="ab1ee06f50f5cef57071b690623be268b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">workflow::timer_id_t wflow::workflow::create_timer </td>
          <td>(</td>
          <td class="paramtype">time_point_t&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">duration_t&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timer_handler&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">expires_at&#160;</td>
          <td class="paramname"><em>expires</em> = <code>expires_at::after</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Создает таймер, обработчик которого выполняется с заданной периодичностью начиная с определенного момента времени </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">tp</td><td>момент времени, начиная с которого запустить таймер </td></tr>
    <tr><td class="paramname">duration</td><td>интервал таймера </td></tr>
    <tr><td class="paramname">handler</td><td>обработчик таймера std::function&lt;bool()&gt;, который должен возвращать true, если таймер должен продолжать работать и false - для завершения. </td></tr>
    <tr><td class="paramname">expires</td><td>если expires_at::after (по умолчанию), то отсчет до следующего запуска после выполнения обработчика таймера</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>идентификатор таймера, который можно использовать для остановки таймера </dd></dl>

</div>
</div>
<a class="anchor" id="a7c41466592cc8f8c2c46b439e4da4fe0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">workflow::timer_id_t wflow::workflow::create_timer </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">duration_t&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timer_handler&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">expires_at&#160;</td>
          <td class="paramname"><em>expires</em> = <code>expires_at::after</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Создает таймер, обработчик которого выполняется с заданной периодичностью начиная с определенного момента времени </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">tp</td><td>момент времени, начиная с которого запустить таймер (строка в формате "22:00:00") </td></tr>
    <tr><td class="paramname">duration</td><td>интервал таймера </td></tr>
    <tr><td class="paramname">handler</td><td>обработчик таймера std::function&lt;bool()&gt;, который должен возвращать true, если таймер должен продолжать работать и false - для завершения. </td></tr>
    <tr><td class="paramname">expires</td><td>если expires_at::after (по умолчанию), то отсчет до следующего запуска после выполнения обработчика таймера</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>идентификатор таймера, который можно использовать для остановки таймера </dd></dl>

</div>
</div>
<a class="anchor" id="a655ba126612a77fe92dd28dfaeae397c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">workflow::timer_id_t wflow::workflow::create_timer </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timer_handler&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">expires_at&#160;</td>
          <td class="paramname"><em>expires</em> = <code>expires_at::after</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Создает таймер, обработчик которого выполняется раз в сутки начиная с определенного момента времени </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">tp</td><td>момент времени, начиная с которого запустить таймер (строка в формате "22:00:00") </td></tr>
    <tr><td class="paramname">handler</td><td>обработчик таймера std::function&lt;bool()&gt;, который должен возвращать true, если таймер должен продолжать работать и false - для завершения. </td></tr>
    <tr><td class="paramname">expires</td><td>если expires_at::after (по умолчанию), то отсчет до следующего запуска после выполнения обработчика таймера</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>идентификатор таймера, который можно использовать для остановки таймера </dd></dl>

</div>
</div>
<a class="anchor" id="a9f8ec8d4bd0205254c6bbb0f698cad43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; bool &gt; wflow::workflow::detach_timer </td>
          <td>(</td>
          <td class="paramtype">timer_id_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Отсоединить таймер. Таймер продолжает работать до тех пор пока существует объект, который вернул detach_timer </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>- идентификатор таймера </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>std::shared_ptr&lt;bool&gt;, если true - таймер работает , false - таймер с таким id не найдено</dd></dl>
<p>простой вызов detach_timer эквивалентен release_timer, но если std::shared_ptr&lt;bool&gt; t = detach_timer(id), то таймер будет продолжать работать до тех пор, пока t.reset() или t = nullptr </p>

</div>
</div>
<a class="anchor" id="a5d4195f4f557ed076268185c4565f780"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wflow::workflow::post </td>
          <td>(</td>
          <td class="paramtype">post_handler&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">drop_handler&#160;</td>
          <td class="paramname"><em>drop</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Отправить задание на обработку </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>обработчик задания типа void() </td></tr>
    <tr><td class="paramname">drop</td><td>альтернативный обработчик, если задание выкидывается из очереди. По умолчанию nullptr (handler выкидывается из очереди без уведомления) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>true - задание поставлено в очередь обработки. false - очередь переполнена, обработчик drop вызван</dd></dl>
<p>При переполнении очереди drop может быть вызван как синхронно (чаще всего) так и асинхронно (если установлена опция rate_limit) </p>

</div>
</div>
<a class="anchor" id="a7f73cc8d8b0296c7d54adf6abc2695d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wflow::workflow::post </td>
          <td>(</td>
          <td class="paramtype">time_point_t&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">post_handler&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">drop_handler&#160;</td>
          <td class="paramname"><em>drop</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Отправить задание на обработку в указанный момент времени </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">tp</td><td>момент времени, в который задание будет отправлено на обработку </td></tr>
    <tr><td class="paramname">handler</td><td>обработчик задания типа void() </td></tr>
    <tr><td class="paramname">drop</td><td>альтернативный обработчик, если задание выкидывается из очереди. По умолчанию nullptr (handler выкидывается из очереди без уведомления) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>true - включен таймер для отправки сообщения. Таймер выкинут из очереди быть не может поэтому всегда true</dd></dl>
<p>В момент времени tp задание будет только отправлено в очередь на обработку (и может быть выкинуто, при переполнении ), в отличии от safe_post, где оно будет выполнено сразу. </p>

</div>
</div>
<a class="anchor" id="aa55118251c8cff0d77cc58a13a7f4a68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wflow::workflow::post </td>
          <td>(</td>
          <td class="paramtype">duration_t&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">post_handler&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">drop_handler&#160;</td>
          <td class="paramname"><em>drop</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Отправить задание на обработку через указанный интервал времени </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>интервал времени, через который задание будет отправлено на обработку </td></tr>
    <tr><td class="paramname">handler</td><td>обработчик задания типа void() </td></tr>
    <tr><td class="paramname">drop</td><td>альтернативный обработчик, если задание выкидывается из очереди. По умолчанию nullptr (handler выкидывается из очереди без уведомления) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>true - включен таймер для отправки сообщения. Таймер выкинут из очереди быть не может поэтому всегда true</dd></dl>
<p>Через указанный интервал времени duration задание будет только отправлено в очередь на обработку (и может быть выкинуто, при переполнении ), в отличии от safe_post, где оно будет выполнено сразу. </p>

</div>
</div>
<a class="anchor" id="a609835e9fafda3a362ebbb472d63268a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wflow::workflow::reconfigure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwflow_1_1workflow__options.html">workflow_options</a>&#160;</td>
          <td class="paramname"><em>opt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Реконфигурация после запуска. Можно изменить число потоков или ограничения очереди.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>- новые опции. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a77db499fea94a94f76eeae3e64449efa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wflow::workflow::release_timer </td>
          <td>(</td>
          <td class="paramtype">timer_id_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Остановить таймер и освободить ресурсы </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">id,идентификатор</td><td>таймера </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>bool, если true - таймер остановлен, false - таймер с таким id не найдено </dd></dl>

</div>
</div>
<a class="anchor" id="aea4296e274c45240aa597f88fa9b2be2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wflow::workflow::safe_post </td>
          <td>(</td>
          <td class="paramtype">post_handler&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Отправить задание на обработку игнорируя ограничения на размер очереди и скорости обработки. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>обработчик задания типа void()</td></tr>
  </table>
  </dd>
</dl>
<p>Аналог boost::asio::io_service::post </p>

</div>
</div>
<a class="anchor" id="a34d4bbe7f9456b3e8a96cdfeadf3566a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wflow::workflow::safe_post </td>
          <td>(</td>
          <td class="paramtype">time_point_t&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">post_handler&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Выполнить задание в указанный момент времени </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">tp</td><td>момент времени, в который задание будет выполнено </td></tr>
    <tr><td class="paramname">handler</td><td>обработчик задания типа void() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef6958512e4be3e7ff55afb0824a5347"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wflow::workflow::safe_post </td>
          <td>(</td>
          <td class="paramtype">duration_t&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">post_handler&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Выполнить задание через указанный интервал времени </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>интервал времени, через который задание будет выполнено </td></tr>
    <tr><td class="paramname">handler</td><td>обработчик задания типа void() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac078e4d80f614092a138d0be0ba78bed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wflow::workflow::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Запуск потоков в многопоточном режиме. При threads=0 вызывать не обязательно </p>

</div>
</div>
<a class="anchor" id="a953d46a7994909524970c4ab750c1f07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wflow::workflow::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Остановка потоков в многопоточном режиме. </p>

</div>
</div>
<hr/>Объявления и описания членов классов находятся в файлах:<ul>
<li>wflow/<a class="el" href="workflow_8hpp_source.html">workflow.hpp</a></li>
<li>wflow/workflow.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Создано системой &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
